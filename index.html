<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Babylon.js Navigation Mesh Example</title>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>
    <script src="https://cdn.babylonjs.com/recast.js"></script>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        const canvas = document.getElementById('renderCanvas');
        const engine = new BABYLON.Engine(canvas, true);

        const createScene = async function () {
            await Recast();
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.2, 0.2, 0.2); // Dark grey background

            // Create a camera
            const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 15, new BABYLON.Vector3(0, 0, 0), scene);
            camera.attachControl(canvas, true);

            // Create a light
            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0), scene);

            // Ground
            const ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 10, height: 10}, scene);
            const groundMaterial = new BABYLON.StandardMaterial("groundMaterial", scene);
            groundMaterial.diffuseColor = new BABYLON.Color3(0.5, 0.5, 0.5); // Grey color
            ground.material = groundMaterial;

            // Obstacles (cubes)
            const obstacleMaterial = new BABYLON.StandardMaterial("obstacleMaterial", scene);
            obstacleMaterial.diffuseColor = new BABYLON.Color3(1, 0, 0); // Red color

            const obstacle1 = BABYLON.MeshBuilder.CreateBox("obstacle1", {size: 1}, scene);
            obstacle1.material = obstacleMaterial;
            obstacle1.position = new BABYLON.Vector3(2, 0.5, 2);

            const obstacle2 = BABYLON.MeshBuilder.CreateBox("obstacle2", {size: 1}, scene);
            obstacle2.material = obstacleMaterial;
            obstacle2.position = new BABYLON.Vector3(-2, 0.5, -2);

            const obstacle3 = BABYLON.MeshBuilder.CreateBox("obstacle3", {size: 1}, scene);
            obstacle3.material = obstacleMaterial;
            obstacle3.position = new BABYLON.Vector3(1, 0.5, -1.5);


            // Create Navigation Mesh
            const navigationPlugin = new BABYLON.RecastJSPlugin();
            navigationPlugin.createNavMesh([ground, obstacle1, obstacle2, obstacle3], {
                cs: 0.2,                           // Cell size
                ch: 0.2,                           // Cell height
                walkableSlopeAngle: 35,            // Walkable slope angle (in degrees)
                walkableHeight: 1,                 // Minimum height at which the agent can walk
                walkableClimb: 1,                  // Maximum height between grid cells that is still considered walkable
                walkableRadius: 1,                 // Radius of the agent
                maxEdgeLen: 12,                    // Maximum allowed length for contour edges along the border of the mesh
                maxSimplificationError: 1.3,       // Maximum distance a simplified contour's border can deviate from the original contour
                minRegionArea: 8,                  // Minimum number of cells allowed to form isolated island areas
                mergeRegionArea: 20,               // Any regions with a span count smaller than this value will, if possible, be merged with larger regions
                maxVertsPerPoly: 6,                // Maximum number of vertices allowed for polygons generated during the voxel to polygon conversion process
                detailSampleDist: 6,               // Sets the sampling distance to use when generating the detail mesh
                detailSampleMaxError: 1            // The maximum distance the detail mesh surface should deviate from the heightfield data
            }, (navmeshData) => {
                console.log("NavMesh created successfully");
                navigationPlugin.buildFromNavmeshData(navmeshData);

                // Visualize NavMesh (optional)
                const navMeshDebug = navigationPlugin.createDebugNavMesh(scene);
                navMeshDebug.material = new BABYLON.StandardMaterial("navMeshDebugMaterial", scene);
                navMeshDebug.material.diffuseColor = new BABYLON.Color3(0, 1, 0); // Green
                navMeshDebug.material.wireframe = true;

                // Model URL
                const modelUrl = "./HoodedCory_NewStart_NewHood_DecimatedCreasedHood-1.glb";
                let agent = null; // This will be our loaded model

                // Load the GLB model
                BABYLON.SceneLoader.ImportMeshAsync("", modelUrl, "", scene).then((result) => {
                    agent = result.meshes[0];
                    agent.name = "player";
                    agent.scaling.scaleInPlace(0.1); // Adjust scale as needed
                    agent.position = new BABYLON.Vector3(3, 0, -3); // Initial position, adjust Y based on model size and pivot

                    // --- Agent-specific setup after model load ---
                    // Example: Make sure the agent is above the ground.
                    // Ground height is 0, if model pivot is at its base, position.y should be 0.
                    // If pivot is at center, might need agent.position.y = modelHeight / 2;
                    // For now, let's assume Y=0 is fine or adjust later.

                    // GUI for target selection (moved inside .then)
                    const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
                    const targetButton = BABYLON.GUI.Button.CreateSimpleButton("targetButton", "Set Target");
                    targetButton.width = "150px";
                    targetButton.height = "40px";
                    targetButton.color = "white";
                    targetButton.background = "green";
                    targetButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
                    targetButton.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
                    advancedTexture.addControl(targetButton);

                    let targetPosition = null;

                    // Handle pointer events for target selection
                    scene.onPointerObservable.add((pointerInfo) => {
                        if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERDOWN) {
                            if (pointerInfo.pickInfo.hit && pointerInfo.pickInfo.pickedMesh === ground) {
                                if (!agent) {
                                    console.log("Agent model not loaded yet.");
                                    return;
                                }
                                targetPosition = pointerInfo.pickInfo.pickedPoint;
                                console.log("Target position set to:", targetPosition);

                                // Calculate path
                                const path = navigationPlugin.computePath(agent.position, targetPosition);
                                if (path && path.length > 0) {
                                    console.log("Path found:", path);
                                    // Animate agent along the path
                                    let currentPathIndex = 0;
                                    const moveNextPoint = () => {
                                        if (currentPathIndex < path.length) {
                                            const targetPoint = path[currentPathIndex];

                                            // --- Animation and Movement ---
                                            // Look at the next point
                                            agent.lookAt(targetPoint);

                                            // TODO: Play walk animation here if available
                                            // e.g., agent.getAnimationGroupByName("walk")?.start(true);

                                            const anim = new BABYLON.Animation(
                                                "agentMove",
                                                "position",
                                                60, // FPS
                                                BABYLON.Animation.ANIMATIONTYPE_VECTOR3,
                                                BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
                                            );
                                            const keys = [];
                                            keys.push({ frame: 0, value: agent.position });
                                            keys.push({ frame: 100, value: targetPoint }); // 100 frames for movement
                                            anim.setKeys(keys);

                                            const onAnimationEnd = () => {
                                                // TODO: Stop walk animation here if it was started
                                                // e.g., agent.getAnimationGroupByName("walk")?.stop();
                                                currentPathIndex++;
                                                moveNextPoint();
                                            };

                                            scene.beginDirectAnimation(agent, [anim], 0, 100, false, 1, onAnimationEnd);

                                        } else {
                                            console.log("Agent reached the target.");
                                            // TODO: Play idle animation here if available
                                            // e.g., agent.getAnimationGroupByName("idle")?.start(true);
                                        }
                                    };
                                    moveNextPoint();
                                } else {
                                    console.log("No path found to the target.");
                                }
                            }
                        }
                    });
                     // --- End of agent-specific setup ---
                }).catch((error) => {
                    console.error("Error loading model:", error);
                });

                // The old agent (sphere) and subsequent GUI/event handling are now moved
                // inside the ImportMeshAsync().then() callback to ensure 'agent' refers to the loaded model.
                // const agent = BABYLON.MeshBuilder.CreateSphere("agent", {diameter: 0.5}, scene);
                // const agentMaterial = new BABYLON.StandardMaterial("agentMaterial", scene);
                // agentMaterial.diffuseColor = new BABYLON.Color3(0, 0, 1); // Blue color
                // agent.material = agentMaterial;
                // agent.position = new BABYLON.Vector3(3, 0.25, -3); // Starting position

                // const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
                // advancedTexture.addControl(targetButton); // Moved
                // let targetPosition = null; // Moved
                // scene.onPointerObservable.add((pointerInfo) => { ... }); // Moved
            });

            return scene;
        };

        // Update the scene creation and rendering logic
        createScene().then(scene => {
            engine.runRenderLoop(function () {
                if (scene) { // Check if scene is not undefined
                    scene.render();
                }
            });
        }).catch(error => {
            console.error("Error creating scene:", error);
        });

        window.addEventListener('resize', function () {
            engine.resize();
        });
    </script>
</body>
</html>
